(function() {
  var EventEmitter, Network, componentLoader, graph, internalSocket, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  internalSocket = require("./InternalSocket");

  graph = require("./Graph");

  if (!require('./Platform').isBrowser()) {
    componentLoader = require("./nodejs/ComponentLoader");
    EventEmitter = require('events').EventEmitter;
  } else {
    componentLoader = require('./ComponentLoader');
    EventEmitter = require('emitter');
  }

  Network = (function(_super) {
    __extends(Network, _super);

    Network.prototype.processes = {};

    Network.prototype.connections = [];

    Network.prototype.initials = [];

    Network.prototype.graph = null;

    Network.prototype.startupDate = null;

    Network.prototype.portBuffer = {};

    function Network(graph) {
      this.processes = {};
      this.connections = [];
      this.initials = [];
      this.graph = graph;
      if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
        this.baseDir = graph.baseDir || process.cwd();
      } else {
        this.baseDir = graph.baseDir || '/';
      }
      this.startupDate = new Date();
      if (graph.componentLoader) {
        this.loader = graph.componentLoader;
      } else {
        this.loader = new componentLoader.ComponentLoader(this.baseDir);
      }
    }

    Network.prototype.uptime = function() {
      return new Date() - this.startupDate;
    };

    Network.prototype.connectionCount = 0;

    Network.prototype.increaseConnections = function() {
      if (this.connectionCount === 0) {
        this.emit('start', {
          start: this.startupDate
        });
      }
      return this.connectionCount++;
    };

    Network.prototype.decreaseConnections = function() {
      var ender,
        _this = this;
      this.connectionCount--;
      if (this.connectionCount === 0) {
        ender = _.debounce(function() {
          if (_this.connectionCount) {
            return;
          }
          return _this.emit('end', {
            start: _this.startupDate,
            end: new Date,
            uptime: _this.uptime()
          });
        }, 10);
        return ender();
      }
    };

    Network.prototype.load = function(component, metadata, callback) {
      return this.loader.load(component, callback, false, metadata);
    };

    Network.prototype.addNode = function(node, callback) {
      var process,
        _this = this;
      if (this.processes[node.id]) {
        if (callback) {
          callback(this.processes[node.id]);
        }
        return;
      }
      process = {
        id: node.id
      };
      if (!node.component) {
        this.processes[process.id] = process;
        if (callback) {
          callback(process);
        }
        return;
      }
      return this.load(node.component, node.metadata, function(instance) {
        var name, port, _ref, _ref1;
        instance.nodeId = node.id;
        process.component = instance;
        _ref = process.component.inPorts;
        for (name in _ref) {
          port = _ref[name];
          if (!port || typeof port === 'function' || !port.canAttach) {
            continue;
          }
          port.node = node.id;
          port.nodeInstance = instance;
          port.name = name;
        }
        _ref1 = process.component.outPorts;
        for (name in _ref1) {
          port = _ref1[name];
          if (!port || typeof port === 'function' || !port.canAttach) {
            continue;
          }
          port.node = node.id;
          port.nodeInstance = instance;
          port.name = name;
        }
        if (instance.isSubgraph()) {
          _this.subscribeSubgraph(process);
        }
        _this.subscribeNode(process);
        _this.processes[process.id] = process;
        if (callback) {
          return callback(process);
        }
      });
    };

    Network.prototype.removeNode = function(node, callback) {
      if (!this.processes[node.id]) {
        return;
      }
      this.processes[node.id].component.shutdown();
      delete this.processes[node.id];
      if (callback) {
        return callback();
      }
    };

    Network.prototype.renameNode = function(oldId, newId, callback) {
      var name, port, process, _ref, _ref1;
      process = this.getNode(oldId);
      if (!process) {
        return;
      }
      process.id = newId;
      _ref = process.component.inPorts;
      for (name in _ref) {
        port = _ref[name];
        port.node = newId;
      }
      _ref1 = process.component.outPorts;
      for (name in _ref1) {
        port = _ref1[name];
        port.node = newId;
      }
      this.processes[newId] = process;
      delete this.processes[oldId];
      if (callback) {
        return callback();
      }
    };

    Network.prototype.getNode = function(id) {
      return this.processes[id];
    };

    Network.prototype.connect = function(done) {
      var edges, initializers, nodes, serialize, subscribeGraph,
        _this = this;
      if (done == null) {
        done = function() {};
      }
      serialize = function(next, add) {
        return function(type) {
          return _this["add" + type](add, function() {
            return next(type);
          });
        };
      };
      subscribeGraph = function() {
        _this.subscribeGraph();
        return done();
      };
      initializers = _.reduceRight(this.graph.initializers, serialize, subscribeGraph);
      edges = _.reduceRight(this.graph.edges, serialize, function() {
        return initializers("Initial");
      });
      nodes = _.reduceRight(this.graph.nodes, serialize, function() {
        return edges("Edge");
      });
      return nodes("Node");
    };

    Network.prototype.connectPort = function(socket, process, port, inbound) {
      if (inbound) {
        socket.to = {
          process: process,
          port: port
        };
        if (!(process.component.inPorts && process.component.inPorts[port])) {
          throw new Error("No inport '" + port + "' defined in process " + process.id + " (" + (socket.getId()) + ")");
          return;
        }
        return process.component.inPorts[port].attach(socket);
      }
      socket.from = {
        process: process,
        port: port
      };
      if (!(process.component.outPorts && process.component.outPorts[port])) {
        throw new Error("No outport '" + port + "' defined in process " + process.id + " (" + (socket.getId()) + ")");
        return;
      }
      return process.component.outPorts[port].attach(socket);
    };

    Network.prototype.subscribeGraph = function() {
      var graphOps, processOps, processing, registerOp,
        _this = this;
      graphOps = [];
      processing = false;
      registerOp = function(op, details) {
        return graphOps.push({
          op: op,
          details: details
        });
      };
      processOps = function() {
        var cb, op;
        if (!graphOps.length) {
          processing = false;
          return;
        }
        processing = true;
        op = graphOps.shift();
        cb = processOps;
        switch (op.op) {
          case 'renameNode':
            return _this.renameNode(op.details.from, op.details.to, cb);
          default:
            return _this[op.op](op.details, cb);
        }
      };
      this.graph.on('addNode', function(node) {
        registerOp('addNode', node);
        if (!processing) {
          return processOps();
        }
      });
      this.graph.on('removeNode', function(node) {
        registerOp('removeNode', node);
        if (!processing) {
          return processOps();
        }
      });
      this.graph.on('renameNode', function(oldId, newId) {
        registerOp('renameNode', {
          from: oldId,
          to: newId
        });
        if (!processing) {
          return processOps();
        }
      });
      this.graph.on('addEdge', function(edge) {
        registerOp('addEdge', edge);
        if (!processing) {
          return processOps();
        }
      });
      this.graph.on('removeEdge', function(edge) {
        registerOp('removeEdge', edge);
        if (!processing) {
          return processOps();
        }
      });
      this.graph.on('addInitial', function(iip) {
        registerOp('addInitial', iip);
        if (!processing) {
          return processOps();
        }
      });
      return this.graph.on('removeInitial', function(iip) {
        registerOp('removeInitial', iip);
        if (!processing) {
          return processOps();
        }
      });
    };

    Network.prototype.subscribeSubgraph = function(node) {
      var emitSub,
        _this = this;
      if (!node.component.isReady()) {
        node.component.once('ready', function() {
          return _this.subscribeSubgraph(node);
        });
        return;
      }
      if (!node.component.network) {
        return;
      }
      emitSub = function(type, data) {
        if (type === 'connect') {
          _this.increaseConnections();
        }
        if (type === 'disconnect') {
          _this.decreaseConnections();
        }
        if (!data) {
          data = {};
        }
        if (data.subgraph) {
          if (!data.subgraph.unshift) {
            data.subgraph = [data.subgraph];
          }
          data.subgraph = data.subgraph.unshift(node.id);
        } else {
          data.subgraph = [node.id];
        }
        return _this.emit(type, data);
      };
      node.component.network.on('connect', function(data) {
        return emitSub('connect', data);
      });
      node.component.network.on('begingroup', function(data) {
        return emitSub('begingroup', data);
      });
      node.component.network.on('data', function(data) {
        return emitSub('data', data);
      });
      node.component.network.on('endgroup', function(data) {
        return emitSub('endgroup', data);
      });
      return node.component.network.on('disconnect', function(data) {
        return emitSub('disconnect', data);
      });
    };

    Network.prototype.subscribeSocket = function(socket) {
      var _this = this;
      socket.on('connect', function() {
        _this.increaseConnections();
        return _this.emit('connect', {
          id: socket.getId(),
          socket: socket
        });
      });
      socket.on('begingroup', function(group) {
        return _this.emit('begingroup', {
          id: socket.getId(),
          socket: socket,
          group: group
        });
      });
      socket.on('data', function(data) {
        return _this.emit('data', {
          id: socket.getId(),
          socket: socket,
          data: data
        });
      });
      socket.on('endgroup', function(group) {
        return _this.emit('endgroup', {
          id: socket.getId(),
          socket: socket,
          group: group
        });
      });
      return socket.on('disconnect', function() {
        _this.decreaseConnections();
        return _this.emit('disconnect', {
          id: socket.getId(),
          socket: socket
        });
      });
    };

    Network.prototype.subscribeNode = function(node) {
      var _this = this;
      if (!node.component.getIcon) {
        return;
      }
      return node.component.on('icon', function() {
        return _this.emit('icon', {
          id: node.id,
          icon: node.component.getIcon()
        });
      });
    };

    Network.prototype.addEdge = function(edge, callback) {
      var from, socket, to,
        _this = this;
      socket = internalSocket.createSocket();
      from = this.getNode(edge.from.node);
      if (!from) {
        throw new Error("No process defined for outbound node " + edge.from.node);
      }
      if (!from.component) {
        throw new Error("No component defined for outbound node " + edge.from.node);
      }
      if (!from.component.isReady()) {
        from.component.once("ready", function() {
          return _this.addEdge(edge, callback);
        });
        return;
      }
      to = this.getNode(edge.to.node);
      if (!to) {
        throw new Error("No process defined for inbound node " + edge.to.node);
      }
      if (!to.component) {
        throw new Error("No component defined for inbound node " + edge.to.node);
      }
      if (!to.component.isReady()) {
        to.component.once("ready", function() {
          return _this.addEdge(edge, callback);
        });
        return;
      }
      this.connectPort(socket, to, edge.to.port, true);
      this.connectPort(socket, from, edge.from.port, false);
      this.subscribeSocket(socket);
      this.connections.push(socket);
      if (callback) {
        return callback();
      }
    };

    Network.prototype.removeEdge = function(edge, callback) {
      var connection, _i, _len, _ref, _results;
      _ref = this.connections;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        connection = _ref[_i];
        if (!connection) {
          continue;
        }
        if (!(edge.to.node === connection.to.process.id && edge.to.port === connection.to.port)) {
          continue;
        }
        connection.to.process.component.inPorts[connection.to.port].detach(connection);
        if (edge.from.node) {
          if (connection.from && edge.from.node === connection.from.process.id && edge.from.port === connection.from.port) {
            connection.from.process.component.outPorts[connection.from.port].detach(connection);
          }
        }
        this.connections.splice(this.connections.indexOf(connection), 1);
        if (callback) {
          _results.push(callback());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Network.prototype.addInitial = function(initializer, callback) {
      var socket, to,
        _this = this;
      socket = internalSocket.createSocket();
      this.subscribeSocket(socket);
      to = this.getNode(initializer.to.node);
      if (!to) {
        throw new Error("No process defined for inbound node " + initializer.to.node);
      }
      if (!(to.component.isReady() || to.component.inPorts[initializer.to.port])) {
        to.component.setMaxListeners(0);
        to.component.once("ready", function() {
          return _this.addInitial(initializer, callback);
        });
        return;
      }
      this.connectPort(socket, to, initializer.to.port, true);
      this.connections.push(socket);
      this.initials.push({
        socket: socket,
        data: initializer.from.data
      });
      if (callback) {
        return callback();
      }
    };

    Network.prototype.removeInitial = function(initializer, callback) {
      var connection, _i, _len, _ref;
      _ref = this.connections;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        connection = _ref[_i];
        if (!connection) {
          continue;
        }
        if (!(initializer.to.node === connection.to.process.id && initializer.to.port === connection.to.port)) {
          continue;
        }
        connection.to.process.component.inPorts[connection.to.port].detach(connection);
        this.connections.splice(this.connections.indexOf(connection), 1);
      }
      if (callback) {
        return callback();
      }
    };

    Network.prototype.sendInitial = function(initial) {
      initial.socket.connect();
      initial.socket.send(initial.data);
      return initial.socket.disconnect();
    };

    Network.prototype.sendInitials = function() {
      var send,
        _this = this;
      send = function() {
        var initial, _i, _len, _ref;
        _ref = _this.initials;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          initial = _ref[_i];
          _this.sendInitial(initial);
        }
        return _this.initials = [];
      };
      if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
        return process.nextTick(send);
      } else {
        return setTimeout(send, 0);
      }
    };

    Network.prototype.start = function() {
      return this.sendInitials();
    };

    Network.prototype.stop = function() {
      var connection, id, process, _i, _len, _ref, _ref1, _results;
      _ref = this.connections;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        connection = _ref[_i];
        if (!connection.isConnected()) {
          continue;
        }
        connection.disconnect();
      }
      _ref1 = this.processes;
      _results = [];
      for (id in _ref1) {
        process = _ref1[id];
        _results.push(process.component.shutdown());
      }
      return _results;
    };

    return Network;

  })(EventEmitter);

  exports.Network = Network;

}).call(this);
