var chai, graph, noflo, path, root, subgraph, urlPrefix,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
  if (!chai) {
    chai = require('chai');
  }
  subgraph = require('../src/components/Graph.coffee');
  graph = require('../src/lib/Graph.coffee');
  noflo = require('../src/lib/NoFlo.coffee');
  path = require('path');
  root = path.resolve(__dirname, '../');
  urlPrefix = './';
} else {
  subgraph = require('noflo/src/components/Graph.js');
  graph = require('noflo/src/lib/Graph.js');
  noflo = require('noflo/src/lib/NoFlo.js');
  root = 'noflo';
  urlPrefix = '/';
}

describe('Graph component', function() {
  var Split, SubgraphMerge, c, g, start;
  c = null;
  g = null;
  start = null;
  beforeEach(function() {
    c = subgraph.getComponent();
    g = noflo.internalSocket.createSocket();
    start = noflo.internalSocket.createSocket();
    c.inPorts.graph.attach(g);
    return c.inPorts.start.attach(start);
  });
  Split = (function(_super) {
    __extends(Split, _super);

    function Split() {
      var _this = this;
      this.inPorts = {
        "in": new noflo.Port
      };
      this.outPorts = {
        out: new noflo.ArrayPort
      };
      this.inPorts["in"].on('connect', function(data) {
        return _this.outPorts.out.connect();
      });
      this.inPorts["in"].on('data', function(data) {
        return _this.outPorts.out.send(data);
      });
      this.inPorts["in"].on('disconnect', function() {
        return _this.outPorts.out.disconnect();
      });
    }

    return Split;

  })(noflo.Component);
  Split.getComponent = function() {
    return new Split;
  };
  SubgraphMerge = function() {
    var inst;
    inst = new noflo.Component;
    inst.inPorts.add('in', function(event, payload, instance) {
      var method;
      method = event;
      if (event === 'data') {
        method = 'send';
      }
      return instance.outPorts[method]('out', payload);
    });
    inst.outPorts.add('out');
    return inst;
  };
  describe('initially', function() {
    it('should be ready', function() {
      return chai.expect(c.ready).to.be["true"];
    });
    it('should not contain a network', function() {
      return chai.expect(c.network).to.be["null"];
    });
    it('should not have a baseDir', function() {
      return chai.expect(c.baseDir).to.be["null"];
    });
    return it('should only have the graph and start inports', function() {
      chai.expect(c.inPorts.ports).to.have.keys(['graph', 'start']);
      return chai.expect(c.outPorts.ports).to.be.empty;
    });
  });
  describe('with JSON graph definition', function() {
    it('should emit a ready event after network has been loaded', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        chai.expect(c.network).not.to.be["null"];
        chai.expect(c.ready).to.be["true"];
        return done();
      });
      c.once('network', function(network) {
        network.loader.components.Split = Split;
        network.loader.registerComponent('', 'Merge', SubgraphMerge);
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        return start.send(true);
      });
      return g.send({
        processes: {
          Split: {
            component: 'Split'
          },
          Merge: {
            component: 'Merge'
          }
        }
      });
    });
    it('should expose available ports', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        chai.expect(c.inPorts.ports).to.have.keys(['graph', 'start', 'merge.in']);
        chai.expect(c.outPorts.ports).to.have.keys(['split.out']);
        return done();
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      return g.send({
        processes: {
          Split: {
            component: 'Split'
          },
          Merge: {
            component: 'Merge'
          }
        },
        connections: [
          {
            src: {
              process: 'Merge',
              port: 'out'
            },
            tgt: {
              process: 'Split',
              port: 'in'
            }
          }
        ]
      });
    });
    it('should update description from the graph', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        chai.expect(c.network).not.to.be["null"];
        chai.expect(c.ready).to.be["true"];
        chai.expect(c.description).to.equal('Hello, World!');
        return done();
      });
      c.once('network', function(network) {
        network.loader.components.Split = Split;
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        chai.expect(c.description).to.equal('Hello, World!');
        return start.send(true);
      });
      return g.send({
        properties: {
          description: 'Hello, World!'
        },
        processes: {
          Split: {
            component: 'Split'
          }
        }
      });
    });
    it('should expose only exported ports when they exist', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        chai.expect(c.inPorts.ports).to.have.keys(['graph', 'start', 'merge.in']);
        chai.expect(c.outPorts.ports).to.have.keys(['out']);
        return done();
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      return g.send({
        exports: [
          {
            "public": 'out',
            "private": 'split.out'
          }
        ],
        processes: {
          Split: {
            component: 'Split'
          },
          Merge: {
            component: 'Merge'
          }
        },
        connections: [
          {
            src: {
              process: 'Merge',
              port: 'out'
            },
            tgt: {
              process: 'Split',
              port: 'in'
            }
          }
        ]
      });
    });
    return it('should be able to run the graph', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        var ins, out;
        ins = noflo.internalSocket.createSocket();
        out = noflo.internalSocket.createSocket();
        c.inPorts['merge.in'].attach(ins);
        c.outPorts['split.out'].attach(out);
        out.on('data', function(data) {
          chai.expect(data).to.equal('Foo');
          return done();
        });
        return ins.send('Foo');
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      return g.send({
        processes: {
          Split: {
            component: 'Split'
          },
          Merge: {
            component: 'Merge'
          }
        },
        connections: [
          {
            src: {
              process: 'Merge',
              port: 'out'
            },
            tgt: {
              process: 'Split',
              port: 'in'
            }
          }
        ]
      });
    });
  });
  describe('with a Graph instance', function() {
    var gr;
    gr = new graph.Graph('Hello, world');
    gr.baseDir = root;
    gr.addNode('Split', 'Split');
    gr.addNode('Merge', 'Merge');
    gr.addEdge('Merge', 'out', 'Split', 'in');
    it('should emit a ready event after network has been loaded', function(done) {
      c.once('ready', function() {
        chai.expect(c.network).not.to.be["null"];
        chai.expect(c.ready).to.be["true"];
        return done();
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      g.send(gr);
      return chai.expect(c.ready).to.be["false"];
    });
    it('should expose available ports', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        chai.expect(c.inPorts.ports).to.have.keys(['graph', 'start', 'merge.in']);
        chai.expect(c.outPorts.ports).to.have.keys(['split.out']);
        return done();
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      return g.send(gr);
    });
    return it('should be able to run the graph', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        var ins, out;
        ins = noflo.internalSocket.createSocket();
        out = noflo.internalSocket.createSocket();
        c.inPorts['merge.in'].attach(ins);
        c.outPorts['split.out'].attach(out);
        out.on('data', function(data) {
          chai.expect(data).to.equal('Foo');
          return done();
        });
        return ins.send('Foo');
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      return g.send(gr);
    });
  });
  describe('with a FBP file with INPORTs and OUTPORTs', function() {
    var file;
    file = "" + urlPrefix + "spec/fixtures/subgraph.fbp";
    it('should emit a ready event after network has been loaded', function(done) {
      c.once('ready', function() {
        chai.expect(c.network).not.to.be["null"];
        chai.expect(c.ready).to.be["true"];
        return done();
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      g.send(file);
      return chai.expect(c.ready).to.be["false"];
    });
    it('should expose available ports', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        chai.expect(c.inPorts.ports).to.have.keys(['graph', 'start', 'in']);
        chai.expect(c.outPorts.ports).to.have.keys(['out']);
        return done();
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      return g.send(file);
    });
    return it('should be able to run the graph', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        var ins, out;
        ins = noflo.internalSocket.createSocket();
        out = noflo.internalSocket.createSocket();
        c.inPorts['in'].attach(ins);
        c.outPorts['out'].attach(out);
        out.on('connect', function() {
          return ins.send('Foo');
        });
        out.on('data', function(data) {
          chai.expect(data).to.equal('Foo');
          return ins.disconnect();
        });
        out.on('disconnect', function() {
          return done();
        });
        return ins.connect();
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      return g.send(file);
    });
  });
  return describe('with a FBP file with legacy EXPORTS', function() {
    var file;
    file = "" + urlPrefix + "spec/fixtures/subgraph_legacy.fbp";
    it('should emit a ready event after network has been loaded', function(done) {
      c.once('ready', function() {
        chai.expect(c.network).not.to.be["null"];
        chai.expect(c.ready).to.be["true"];
        return done();
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      g.send(file);
      return chai.expect(c.ready).to.be["false"];
    });
    it('should expose available ports', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        chai.expect(c.inPorts.ports).to.have.keys(['graph', 'start', 'in']);
        chai.expect(c.outPorts.ports).to.have.keys(['out']);
        return done();
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      return g.send(file);
    });
    it('should have disambiguated the exported ports', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        chai.expect(c.network.graph.exports).to.be.empty;
        chai.expect(c.network.graph.inports).to.be.not.empty;
        chai.expect(c.network.graph.inports["in"]).to.be.an('object');
        chai.expect(c.network.graph.outports).to.be.not.empty;
        chai.expect(c.network.graph.outports.out).to.be.an('object');
        return done();
      });
      c.once('network', function() {
        c.network.loader.components.Split = Split;
        return c.network.loader.components.Merge = SubgraphMerge;
      });
      return g.send(file);
    });
    return it('should be able to run the graph', function(done) {
      c.baseDir = root;
      c.once('ready', function() {
        var ins, out;
        ins = noflo.internalSocket.createSocket();
        out = noflo.internalSocket.createSocket();
        c.inPorts['in'].attach(ins);
        c.outPorts['out'].attach(out);
        out.on('connect', function() {
          return ins.send('Foo');
        });
        out.on('data', function(data) {
          chai.expect(data).to.equal('Foo');
          return ins.disconnect();
        });
        out.on('disconnect', function() {
          return done();
        });
        return ins.connect();
      });
      c.once('network', function() {
        chai.expect(c.ready).to.be["false"];
        chai.expect(c.network).not.to.be["null"];
        c.network.loader.components.Split = Split;
        c.network.loader.components.Merge = SubgraphMerge;
        return start.send(true);
      });
      return g.send(file);
    });
  });
});
