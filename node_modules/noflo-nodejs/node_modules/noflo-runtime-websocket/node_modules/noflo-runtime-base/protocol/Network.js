(function() {
  var NetworkProtocol, noflo, prepareSocketEvent;

  noflo = require('noflo');

  prepareSocketEvent = function(event, req) {
    var payload;
    payload = {
      id: event.id,
      graph: req.graph
    };
    if (event.socket.from) {
      payload.src = {
        node: event.socket.from.process.id,
        port: event.socket.from.port
      };
    }
    if (event.socket.to) {
      payload.tgt = {
        node: event.socket.to.process.id,
        port: event.socket.to.port
      };
    }
    if (event.subgraph) {
      payload.subgraph = event.subgraph;
    }
    if (event.group) {
      payload.group = event.group;
    }
    if (event.data) {
      if (event.data.toJSON) {
        payload.data = event.data.toJSON();
      }
      if (event.data.toString) {
        payload.data = event.data.toString();
        if (payload.data === '[object Object]') {
          try {
            payload.data = JSON.parse(JSON.stringify(event.data));
          } catch (_error) {}
        }
      } else {
        payload.data = event.data;
      }
    }
    if (event.subgraph) {
      payload.subgraph = event.subgraph;
    }
    return payload;
  };

  NetworkProtocol = (function() {
    function NetworkProtocol(transport) {
      this.transport = transport;
      this.networks = {};
    }

    NetworkProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('network', topic, payload, context);
    };

    NetworkProtocol.prototype.receive = function(topic, payload, context) {
      var graph;
      graph = this.resolveGraph(payload, context);
      if (!graph) {
        return;
      }
      switch (topic) {
        case 'start':
          return this.initNetwork(graph, payload, context);
        case 'stop':
          return this.stopNetwork(graph, payload, context);
      }
    };

    NetworkProtocol.prototype.resolveGraph = function(payload, context) {
      if (!payload.graph) {
        this.send('error', new Error('No graph specified'), context);
        return;
      }
      if (!this.transport.graph.graphs[payload.graph]) {
        this.send('error', new Error('Requested graph not found'), context);
        return;
      }
      return this.transport.graph.graphs[payload.graph];
    };

    NetworkProtocol.prototype.initNetwork = function(graph, payload, context) {
      var _this = this;
      graph.componentLoader = this.transport.component.getLoader(graph.baseDir);
      return noflo.createNetwork(graph, function(network) {
        _this.networks[payload.graph] = network;
        _this.subscribeNetwork(network, payload, context);
        return network.connect(function() {
          network.sendInitials();
          return graph.on('addInitial', function() {
            return network.sendInitials();
          });
        });
      }, true);
    };

    NetworkProtocol.prototype.subscribeNetwork = function(network, payload, context) {
      var _this = this;
      network.on('start', function(event) {
        return _this.send('started', {
          time: event.start,
          graph: payload.graph
        }, context);
      });
      network.on('icon', function(event) {
        event.graph = payload.graph;
        return _this.send('icon', event, context);
      });
      network.on('connect', function(event) {
        return _this.send('connect', prepareSocketEvent(event, payload), context);
      });
      network.on('begingroup', function(event) {
        return _this.send('begingroup', prepareSocketEvent(event, payload), context);
      });
      network.on('data', function(event) {
        return _this.send('data', prepareSocketEvent(event, payload), context);
      });
      network.on('endgroup', function(event) {
        return _this.send('endgroup', prepareSocketEvent(event, payload), context);
      });
      network.on('disconnect', function(event) {
        return _this.send('disconnect', prepareSocketEvent(event, payload), context);
      });
      return network.on('end', function(event) {
        return _this.send('stopped', {
          time: new Date,
          uptime: event.uptime,
          graph: payload.graph
        }, context);
      });
    };

    NetworkProtocol.prototype.stopNetwork = function(graph, payload, context) {
      if (!this.networks[payload.graph]) {
        return;
      }
      return this.networks[payload.graph].stop();
    };

    return NetworkProtocol;

  })();

  module.exports = NetworkProtocol;

}).call(this);
