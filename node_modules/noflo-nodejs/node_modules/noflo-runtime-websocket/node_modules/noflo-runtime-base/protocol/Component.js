(function() {
  var ComponentProtocol, noflo;

  noflo = require('noflo');

  ComponentProtocol = (function() {
    ComponentProtocol.prototype.loaders = {};

    function ComponentProtocol(transport) {
      this.transport = transport;
    }

    ComponentProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('component', topic, payload, context);
    };

    ComponentProtocol.prototype.receive = function(topic, payload, context) {
      switch (topic) {
        case 'list':
          return this.listComponents(payload, context);
        case 'getsource':
          return this.getSource(payload, context);
        case 'source':
          return this.setSource(payload, context);
      }
    };

    ComponentProtocol.prototype.getLoader = function(baseDir) {
      if (!this.loaders[baseDir]) {
        this.loaders[baseDir] = new noflo.ComponentLoader(baseDir);
      }
      return this.loaders[baseDir];
    };

    ComponentProtocol.prototype.listComponents = function(payload, context) {
      var baseDir, loader,
        _this = this;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir);
      return loader.listComponents(function(components) {
        return Object.keys(components).forEach(function(component) {
          return _this.processComponent(loader, component, context);
        });
      });
    };

    ComponentProtocol.prototype.getSource = function(payload, context) {
      var baseDir, loader,
        _this = this;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir);
      return loader.getSource(payload.name, function(err, component) {
        if (err) {
          _this.send('error', err, context);
          return;
        }
        return _this.send('source', component, context);
      });
    };

    ComponentProtocol.prototype.setSource = function(payload, context) {
      var baseDir, loader,
        _this = this;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir);
      return loader.setSource(payload.library, payload.name, payload.code, payload.language, function(err) {
        if (err) {
          _this.send('error', err, context);
          return;
        }
        return _this.processComponent(loader, loader.normalizeName(payload.library, payload.name), context);
      });
    };

    ComponentProtocol.prototype.processComponent = function(loader, component, context) {
      var _this = this;
      return loader.load(component, function(instance) {
        if (!instance.isReady()) {
          instance.once('ready', function() {
            return _this.sendComponent(component, instance, context);
          });
          return;
        }
        return _this.sendComponent(component, instance, context);
      }, true);
    };

    ComponentProtocol.prototype.sendComponent = function(component, instance, context) {
      var icon, inPorts, outPorts, port, portName, _ref, _ref1;
      inPorts = [];
      outPorts = [];
      _ref = instance.inPorts;
      for (portName in _ref) {
        port = _ref[portName];
        if (!port || typeof port === 'function' || !port.canAttach) {
          continue;
        }
        inPorts.push({
          id: portName,
          type: port.getDataType ? port.getDataType() : void 0,
          required: port.isRequired ? port.isRequired() : void 0,
          addressable: port.isAddressable ? port.isAddressable() : void 0,
          description: port.getDescription ? port.getDescription() : void 0
        });
      }
      _ref1 = instance.outPorts;
      for (portName in _ref1) {
        port = _ref1[portName];
        if (!port || typeof port === 'function' || !port.canAttach) {
          continue;
        }
        outPorts.push({
          id: portName,
          type: port.getDataType ? port.getDataType() : void 0,
          required: port.isRequired ? port.isRequired() : void 0,
          addressable: port.isAddressable ? port.isAddressable() : void 0,
          description: port.getDescription ? port.getDescription() : void 0
        });
      }
      icon = instance.getIcon ? instance.getIcon() : 'blank';
      return this.send('component', {
        name: component,
        description: instance.description,
        subgraph: instance.isSubgraph(),
        icon: icon,
        inPorts: inPorts,
        outPorts: outPorts
      }, context);
    };

    ComponentProtocol.prototype.registerGraph = function(id, graph, context) {
      var loader, send,
        _this = this;
      send = function() {
        return _this.processComponent(loader, id, context);
      };
      loader = this.getLoader(graph.baseDir);
      loader.listComponents(function(components) {
        loader.registerComponent('', id, graph);
        return send();
      });
      graph.on('addNode', send);
      graph.on('removeNode', send);
      graph.on('renameNode', send);
      graph.on('addEdge', send);
      graph.on('removeEdge', send);
      graph.on('addInitial', send);
      graph.on('removeInitial', send);
      graph.on('addInport', send);
      graph.on('removeInport', send);
      graph.on('renameInport', send);
      graph.on('addOutport', send);
      graph.on('removeOutport', send);
      return graph.on('renameOutport', send);
    };

    return ComponentProtocol;

  })();

  module.exports = ComponentProtocol;

}).call(this);
