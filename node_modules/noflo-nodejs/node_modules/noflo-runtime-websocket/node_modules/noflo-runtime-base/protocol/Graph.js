(function() {
  var GraphProtocol, noflo;

  noflo = require('noflo');

  GraphProtocol = (function() {
    function GraphProtocol(transport) {
      this.transport = transport;
      this.graphs = {};
    }

    GraphProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('graph', topic, payload, context);
    };

    GraphProtocol.prototype.receive = function(topic, payload, context) {
      var graph;
      if (topic !== 'clear') {
        graph = this.resolveGraph(payload, context);
        if (!graph) {
          return;
        }
      }
      switch (topic) {
        case 'clear':
          return this.initGraph(payload, context);
        case 'addnode':
          return this.addNode(graph, payload, context);
        case 'removenode':
          return this.removeNode(graph, payload, context);
        case 'renamenode':
          return this.renameNode(graph, payload, context);
        case 'addedge':
          return this.addEdge(graph, payload, context);
        case 'removeedge':
          return this.removeEdge(graph, payload, context);
        case 'addinitial':
          return this.addInitial(graph, payload, context);
        case 'removeinitial':
          return this.removeInitial(graph, payload, context);
        case 'addinport':
          return this.addInport(graph, payload, context);
        case 'removeinport':
          return this.removeInport(graph, payload, context);
        case 'renameinport':
          return this.renameInport(graph, payload, context);
        case 'addoutport':
          return this.addOutport(graph, payload, context);
        case 'removeoutport':
          return this.removeOutport(graph, payload, context);
        case 'renameoutport':
          return this.renameOutport(graph, payload, context);
      }
    };

    GraphProtocol.prototype.resolveGraph = function(payload, context) {
      if (!payload.graph) {
        this.send('error', new Error('No graph specified'), context);
        return;
      }
      if (!this.graphs[payload.graph]) {
        this.send('error', new Error('Requested graph not found'), context);
        return;
      }
      return this.graphs[payload.graph];
    };

    GraphProtocol.prototype.initGraph = function(payload, context) {
      var fullName, graph;
      if (!payload.id) {
        this.send('error', new Error('No graph ID provided'), context);
        return;
      }
      if (!payload.name) {
        payload.name = 'NoFlo runtime';
      }
      graph = new noflo.Graph(payload.name);
      fullName = payload.id;
      if (payload.library) {
        graph.properties.library = payload.library;
        fullName = "" + payload.library + "/" + fullName;
      }
      graph.baseDir = this.transport.options.baseDir;
      this.subscribeGraph(payload.id, graph, context);
      if (!payload.main) {
        this.transport.component.registerGraph(fullName, graph, context);
      }
      return this.graphs[payload.id] = graph;
    };

    GraphProtocol.prototype.subscribeGraph = function(id, graph, context) {
      var _this = this;
      graph.on('addNode', function(node) {
        node.graph = id;
        return _this.send('addnode', node, context);
      });
      graph.on('removeNode', function(node) {
        node.graph = id;
        return _this.send('removenode', node, context);
      });
      graph.on('renameNode', function(oldId, newId) {
        return _this.send('renamenode', {
          from: oldId,
          to: newId,
          graph: id
        }, context);
      });
      graph.on('addEdge', function(edge) {
        var edgeData;
        edgeData = {
          src: edge.from,
          tgt: edge.to,
          metadata: edge.metadata,
          graph: id
        };
        return _this.send('addedge', edgeData, context);
      });
      graph.on('removeEdge', function(edge) {
        var edgeData;
        edgeData = {
          src: edge.from,
          tgt: edge.to,
          metadata: edge.metadata,
          graph: id
        };
        return _this.send('removeedge', edgeData, context);
      });
      graph.on('addInitial', function(iip) {
        var iipData;
        iipData = {
          src: iip.from,
          tgt: iip.to,
          metadata: iip.metadata,
          graph: id
        };
        return _this.send('addinitial', iipData, context);
      });
      return graph.on('removeInitial', function(iip) {
        var iipData;
        iipData = {
          src: iip.from,
          tgt: iip.to,
          metadata: iip.metadata,
          graph: id
        };
        return _this.send('removeinitial', iipData, context);
      });
    };

    GraphProtocol.prototype.addNode = function(graph, node, context) {
      if (!(node.id || node.component)) {
        this.send('error', new Error('No ID or component supplied'), context);
        return;
      }
      return graph.addNode(node.id, node.component, node.metadata);
    };

    GraphProtocol.prototype.removeNode = function(graph, payload) {
      if (!payload.id) {
        this.send('error', new Error('No ID supplied'), context);
        return;
      }
      return graph.removeNode(payload.id);
    };

    GraphProtocol.prototype.renameNode = function(graph, payload, context) {
      if (!(payload.from || payload.to)) {
        this.send('error', new Error('No from or to supplied'), context);
        return;
      }
      return graph.renameNode(payload.from, payload.to);
    };

    GraphProtocol.prototype.addEdge = function(graph, edge, context) {
      if (!(edge.src || edge.tgt)) {
        this.send('error', new Error('No src or tgt supplied'), context);
        return;
      }
      return graph.addEdge(edge.src.node, edge.src.port, edge.tgt.node, edge.tgt.port, edge.metadata);
    };

    GraphProtocol.prototype.removeEdge = function(graph, edge, context) {
      if (!(edge.src || edge.tgt)) {
        this.send('error', new Error('No src or tgt supplied'), context);
        return;
      }
      return graph.removeEdge(edge.src.node, edge.src.port, edge.tgt.node, edge.tgt.port);
    };

    GraphProtocol.prototype.addInitial = function(graph, payload, context) {
      if (!(payload.src || payload.tgt)) {
        this.send('error', new Error('No src or tgt supplied'), context);
        return;
      }
      return graph.addInitial(payload.src.data, payload.tgt.node, payload.tgt.port, payload.metadata);
    };

    GraphProtocol.prototype.removeInitial = function(graph, payload, context) {
      if (!payload.tgt) {
        this.send('error', new Error('No tgt supplied'), context);
        return;
      }
      return graph.removeInitial(payload.tgt.node, payload.tgt.port);
    };

    GraphProtocol.prototype.addInport = function(graph, payload, context) {
      if (!(payload["public"] || payload.node || payload.port)) {
        this.send('error', new Error('Missing exported inport information'), context);
        return;
      }
      return graph.addInport(payload["public"], payload.node, payload.port, payload.metadata);
    };

    GraphProtocol.prototype.removeInport = function(graph, payload, context) {
      if (!payload["public"]) {
        this.send('error', new Error('Missing exported inport name'), context);
        return;
      }
      return graph.removeInport(payload["public"]);
    };

    GraphProtocol.prototype.renameInport = function(graph, payload, context) {
      if (!(payload.from || payload.to)) {
        this.send('error', new Error('No from or to supplied'), context);
        return;
      }
      return graph.renameInport(payload.from, payload.to);
    };

    GraphProtocol.prototype.addOutport = function(graph, payload, context) {
      if (!(payload["public"] || payload.node || payload.port)) {
        this.send('error', new Error('Missing exported outport information'), context);
        return;
      }
      return graph.addOutport(payload["public"], payload.node, payload.port, payload.metadata);
    };

    GraphProtocol.prototype.removeOutport = function(graph, payload, context) {
      if (!payload["public"]) {
        this.send('error', new Error('Missing exported outport name'), context);
        return;
      }
      return graph.removeOutport(payload["public"]);
    };

    GraphProtocol.prototype.renameOutport = function(graph, payload, context) {
      if (!(payload.from || payload.to)) {
        this.send('error', new Error('No from or to supplied'), context);
        return;
      }
      return graph.renameOutport(payload.from, payload.to);
    };

    return GraphProtocol;

  })();

  module.exports = GraphProtocol;

}).call(this);
