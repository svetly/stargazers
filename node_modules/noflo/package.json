{
  "name": "noflo",
  "description": "Flow-Based Programming environment for Node.js",
  "keywords": [
    "fbp",
    "workflow",
    "flow"
  ],
  "author": {
    "name": "Henri Bergius",
    "email": "henri.bergius@iki.fi"
  },
  "contributors": [
    {
      "name": "Jerry Jalava"
    },
    {
      "name": "Ryan Shaw"
    }
  ],
  "version": "0.3.4",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/bergie/noflo/raw/master/LICENSE"
    }
  ],
  "engines": {
    "node": ">=0.6.0"
  },
  "dependencies": {
    "shell": "0.2.x",
    "cli": ">=0.3.7",
    "cli-color": ">=0.2.1",
    "underscore": ">=1.3.3",
    "read-installed": "0.0.x",
    "npmlog": "0.0.x",
    "coffee-script": ">=1.1.0"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-coffee": "~0.6.6",
    "grunt-cli": "~0.1.7",
    "grunt-contrib-nodeunit": "~0.1.2",
    "grunt-coffeelint": "0.0.6",
    "grunt-bumpup": "~0.2.0",
    "grunt-tagrelease": "~0.2.0",
    "grunt-exec": "~0.4.0"
  },
  "main": "./lib/NoFlo",
  "bin": {
    "noflo": "./bin/noflo"
  },
  "homepage": "http://noflojs.org/",
  "repository": {
    "type": "git",
    "url": "git://github.com/bergie/noflo.git"
  },
  "scripts": {
    "test": "grunt test"
  },
  "docco_husky": {
    "output_dir": "docs",
    "project_name": "NoFlo"
  },
  "readme": "NoFlo: Flow-based programming for Node.js [![Build Status](https://secure.travis-ci.org/bergie/noflo.png?branch=master)](http://travis-ci.org/bergie/noflo)\n=========================================\n\nNoFlo is a simple [flow-based programming](http://en.wikipedia.org/wiki/Flow-based_programming) implementation for Node.js. From WikiPedia:\n\n> In computer science, flow-based programming (FBP) is a programming paradigm that defines applications as networks of \"black box\" processes, which exchange data across predefined connections by message passing, where the connections are specified externally to the processes. These black box processes can be reconnected endlessly to form different applications without having to be changed internally. FBP is thus naturally component-oriented.\n\nDevelopers used to the [Unix philosophy](http://en.wikipedia.org/wiki/Unix_philosophy) should be immediately familiar with FBP:\n\n> This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.\n\nIt also fits well in Alan Kay's [original idea of object-oriented programming](http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en):\n\n> I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages (so messaging came at the very beginning -- it took a while to see how to do messaging in a programming language efficiently enough to be useful).\n\nNoFlo has been written in [CoffeeScript](http://jashkenas.github.com/coffee-script) for simplicity. The system is heavily inspired by [J. Paul Morrison's](http://www.jpaulmorrison.com/) book [Flow-Based Programming](http://www.jpaulmorrison.com/fbp/#More). \n\nCurrently NoFlo is still in quite early stages. It has already been used in some real-world applications, but the small number of available components still limits the utility of the system.\n\n## Requirements and installing\n\nNoFlo is available [via NPM](https://npmjs.org/package/noflo), so you can install it with:\n\n    $ npm install -g noflo\n\n### Installing from Git\n\nNoFlo requires a reasonably recent version of [Node.js](http://nodejs.org/), and some [npm](http://npmjs.org/) packages. Ensure you have the `grunt-cli` package installed (`grunt` command should be available on command line) and NoFlo checked out from Git. Build NoFlo with:\n\n    $ grunt build\n\nThen you can install everything needed by a simple:\n\n    $ npm link\n\nNoFlo is available from [GitHub](https://github.com/bergie/noflo) under the MIT license.\n\n## Changes\n\nPlease refer to the [CHANGES.md document](https://github.com/bergie/noflo/blob/master/CHANGES.md).\n\n## Using NoFlo\n\nThere are two ways to use NoFlo:\n\n* _Independent_: Building the whole control logic of your software as a NoFlo graph, and running it with the `noflo` tool\n* _Embedded_: Using NoFlo as a library and calling some NoFlo graphs whenever your software needs workflows\n\nWhen you create a NoFlo graph, it doesn't do anything by itself. It only loads the components of the graph and sets up the connections between them. Then it is up to the components to actually start sending messages to their outports, or reacting to messages they receive on their inports.\n\nSince most components require some input before they act, the usual way to make a NoFlo graph run is to send it some _initial information packets_, or IIPs. Examples of this would include sending a port number that a web server could listen to the web server component, or sending a file name to a file reader.\n\nThis activation model provides many possibilities:\n\n* Starting the graph based on user interaction (shell command, clicking a button)\n* Starting the graph based on a received signal (Redis pub/sub, D-Bus signal, WebHook, email)\n* Starting the graph at a given time or interval (running a graph on the first of every month, or five minutes from now)\n* Starting the graph based on context (when arriving to a physical location, when user goes to a given web site)\n\n### Running the examples\n\nFile line count using _embedded_ NoFlo:\n\n    $ coffee ./examples/linecount/count.coffee somefile.txt\n\nFile line count as an _individual_ NoFlo application:\n\n    $ noflo -i\n    NoFlo>> load examples/linecount/count.json\n\nor\n\n    $ noflo examples/linecount/count.json\n\nSimple \"Hello, world\" web service with Basic authentication using _embedded_ NoFlo:\n\n    $ coffee ./examples/http/hello.coffee\n\nThen just point your browser to [http://localhost:8003/](http://localhost:8003/). Note that this example needs to have `connect` NPM package installed. Username is `user` and password is `pass`.\n\n## Terminology\n\n* Component: individual, pluggable and reusable piece of software. In this case a NoFlo-compatible CommonJS module\n* Graph: the control logic of a FBP application, can be either in programmatical or file format\n* Inport: inbound port of a component\n* Network: collection of processes connected by sockets. A running version of a graph\n* Outport: outbound port of a component\n* Process: an instance of a component that is running as part of a graph\n\n## Components\n\nA component is the main ingredient of flow-based programming. Component is a CommonJS module providing a set of input and output port handlers. These ports are used for connecting components to each other.\n\nNoFlo processes (the boxes of a flow graph) are instances of a component, with the graph controlling connections between ports of components.\n\nSince version 0.2.0, NoFlo has been able to utilize components shared via NPM packages. [Read the introductory blog post](http://bergie.iki.fi/blog/distributing-noflo-components/) to learn more.\n\n### Structure of a component\n\nFunctionality a component provides:\n\n* List of inports (named inbound ports)\n* List of outports (named outbound ports)\n* Handler for component initialization that accepts configuration\n* Handler for connections for each inport\n\nMinimal component written in CoffeeScript would look like the following:\n\n```coffeescript\nnoflo = require \"noflo\"\n\nclass Forwarder extends noflo.Component\n    description: \"This component receives data on a single input \n    port and sends the same data out to the output port\"\n\n    constructor: ->\n        # Register ports\n        @inPorts =\n            in: new noflo.Port()\n        @outPorts =\n            out: new noflo.Port()\n\n        @inPorts.in.on \"data\", (data) =>\n            # Forward data when we receive it.\n            # Note: send() will connect automatically if needed\n            @outPorts.out.send data\n\n        @inPorts.in.on \"disconnect\", =>\n            # Disconnect output port when input port disconnects\n            @outPorts.out.disconnect()\n\nexports.getComponent = ->\n    new Forwarder()\n```\n\nThis example component register two ports: _in_ and _out_. When it receives data in the _in_ port, it opens the _out_ port and sends the same data there. When the _in_ connection closes, it will also close the _out_ connection. So basically this component would be a simple repeater.\n\nYou can find more examples of components in the `components` folder shipping with NoFlo.\n\n### Subgraphs\n\nA NoFlo graph may contain multiple subgraphs, managed by instances of the `Graph` component. Subgraphs are useful for packaging particular flows to be used as a \"new component\" by other flows. This allows building more advanced functionality by creating reusable graphs of connected components.\n\nThe Graph component loads the graph given to it as a new NoFlo network, and looks for unattached ports in it. It then exposes these ports as its own inports or outports. This way a graph containing subgraphs can easily connect data between the main graph and the subgraph.\n\nUnattached ports from the subgraph will be available through naming `ProcessName.port` on the Graph component instance.\n\nSimple example, specifying what file a spreadsheet-parsing subgraph should run with:\n\n```fbp\n# Load a subgraph as a new process\n'examples/spreadsheet/parse.fbp' -> GRAPH Reader(Graph)\n# Send the filename to the component (subgraph)\n'somefile.xls' -> READ.SOURCE Reader()\n# Display the results\nReader() ENTITIZE.OUT -> IN Display(Output)\n```\n\nJust like with components, it is possible to share subgraphs via NPM. You have to register them in your `package.json`, for example:\n\n```json\n  \"name\": \"noflo-spreadsheet\",\n  \"noflo\": {\n    \"graphs\": {\n      \"Parse\": \"./graphs/parse.fbp\"\n    }\n  }\n```\n\nAfter this the subgraph is available as a \"virtual component\" with the name `spreadsheet/Parse` and can be used just like any other component. Subgraphs exported in this manner can be in either JSON or the `.fbp` format.\n\n### Some words on component design\n\nComponents should aim to be reusable, to do one thing and do it well. This is why often it is a good idea to split functionality traditionally done in one function to multiple components. For example, counting lines in a text file could happen in the following way:\n\n* Filename is sent to a _Read File_ component\n* _Read File_ reads it and sends the contents onwards to _Split String_ component\n* _Split String_ splits the contents by newlines, and sends each line separately to a _Count_ component\n* _Count_ counts the number of packets it received, and sends the total to a _Output_ component\n* _Output_ displays the number\n\nThis way the whole logic of the application is in the graph, in how the components are wired together. And each of the components is easily reusable for other purposes.\n\nIf a component requires configuration, the good approach is to set sensible defaults in the component, and to allow them to be overridden via an input port. This method of configuration allows the settings to be kept in the graph itself, or for example to be read from a file or database, depending on the needs of the application.\n\nThe components should not depend on a particular global state, either, but instead attempt to keep the input and output ports their sole interface to the external world. There may be some exceptions, like a component that listens for HTTP requests or Redis pub-sub messages, but even in these cases the server, or subscription should be set up by the component itself.\n\nWhen discussing how to solve the unnecessary complexity of software, _Out of the Tar Pit_ promotes an approach quite similar to the one discussed here:\n\n> The first thing that we’re doing is to advocate separating out all complexity of any kind from the pure logic of the system (which - having nothing to do with either state or control - we’re not really considering part of the complexity).\n\nDone this way, components represent the pure logic, and the control flow and state of the application is managed separately of them in the graph. This separation makes the system a lot simpler.\n\n### Ports and events\n\nBeing a flow-based programming environment, the main action in NoFlo happens through ports and their connections. There are several events that can be associated with ports:\n\n* _Attach_: there is a connection to the port\n* _Connect_: the port has started sending or receiving a data transmission\n* _BeginGroup_: the data stream after this event is associated with a given named group. Components may or may not utilize this information\n* _Data_: an individual data packet in a transmission. There might be multiple depending on how a component operates\n* _EndGroup_: A particular grouped stream of data ends\n* _Disconnect_: end of data transmission\n* _Detach_: A connection to the port has been removed\n\nIt depends on the nature of the component how these events may be handled. Most typical components do operations on a whole transmission, meaning that they should wait for the _disconnect_ event on inports before they act, but some components can also act on single _data_ packets coming in.\n\nWhen a port has no connections, meaning that it was initialized without a connection, or a _detach_ event has happened, it should do no operations regarding that port.\n\n## The NoFlo shell\n\nNoFlo comes with a command shell that you can use to load, run and manipulate NoFlo graphs. For example, the _line count_ graph that was explained in _Component design_ could be built with the shell in the following way:\n\n    $ noflo\n    NoFlo>> new countlines\n    countlines>> add read ReadFile\n    countlines>> add split SplitStr\n    countlines>> add count Counter\n    countlines>> add display Output\n    countlines>> connect read out split in\n    countlines>> connect split out count in\n    countlines>> connect count count display in\n    countlines>> dot\n    digraph {\n      read [shape=box]\n      split [shape=box]\n      count [shape=box]\n      display [shape=box]\n      read -> split[label='out']\n      split -> count[label='out']\n      count -> display[label='count']\n    }\n    countlines>> send read source somefile\n\nYou can run _help_ to see all available NoFlo shell commands, and _quit_ to get out of the shell.\n\n## Designing NoFlo graphs with DrawFBP\n\nAs of version 2.6 onwards, the [DrawFBP](http://www.jpaulmorrison.com/cgi-bin/wiki.pl?DrawFBP) GUI tool for designing Flow-Based Programming graphs is able to generate graphs compatible with NoFlo.\n\nThe graphs can be exported to NoFlo format from the _File -> Generate network -> NoFlo_ menu and then run normally.\n\n## The web-based NoFlo monitor\n\nIn addition to the shell, NoFlo also comes with a web interface that allows loaded graphs to be monitored. To start it, load a graph into the NoFlo shell, and run:\n\n    >> startserver 8080\n\nThis will start the NoFlo monitor on port `8080` of your system, so browsers can connect to it with `http://localhost:8080`. You can also use another port number.\n\nAt the moment the monitor only displays the graph, showing the processes and connections between them. Real-time statistics of data flow, and support for visual graph editing are planned.\n\n## NoFlo graph file format\n\nIn addition to using NoFlo in _embedded mode_ where you create the FBP graph programmatically ([see example](https://raw.github.com/bergie/noflo/master/examples/linecount/count.coffee)), you can also initialize and run graphs defined using a JSON file.\n\nThe NoFlo JSON files declare the processes used in the FBP graph, and the connections between them. They look like the following:\n\n```json\n{\n    \"properties\": {\n        \"name\": \"Count lines in a file\"\n    },\n    \"processes\": {\n        \"Read File\": {\n            \"component\": \"ReadFile\"\n        },\n        \"Split by Lines\": {\n            \"component\": \"SplitStr\"\n        },\n        ...\n    },\n    \"connections\": [\n        {\n            \"data\": \"package.json\",\n            \"tgt\": {\n                \"process\": \"Read File\",\n                \"port\": \"source\"\n            }\n        },\n        {\n            \"src\": {\n                \"process\": \"Read File\",\n                \"port\": \"out\"\n            },\n            \"tgt\": {\n                \"process\": \"Split by Lines\",\n                \"port\": \"in\"\n            }\n        },\n        ...\n    ]\n}\n```\n\nTo run a graph file, you can either use the _load_ command of the NoFlo shell, or do it programmatically:\n\n```coffeescript\nnoflo = require \"noflo\"\nnoflo.loadFile \"example.json\", (network) ->\n    console.log \"Graph loaded\"\n    console.log network.graph.toDOT()\n```\n\n## Language for Flow-Based Programming\n\nIn addition to the JSON format described above, FBP has its own Domain-Specific Language (DSL) for easy graph definition. The syntax is the following:\n\n* `'somedata' -> PORT Process(Component)` sends initial data _somedata_ to port _PORT_ of process _Process_ that runs component _Component_\n* `A(Component1) X -> Y B(Component2)` sets up a connection between port _X_ of process _A_ that runs component _Component1_ and port _Y_ of process _B_ that runs component _Component2_\n\nYou can connect multiple components and ports together on one line, and separate connection definitions with a newline or a comma (`,`). \n\nComponents only have to be specified the first time you mention a new process. Afterwards, simply append empty parentheses (`()`) after the process name.\n\nExample:\n\n```fbp\n'somefile.txt' -> SOURCE Read(ReadFile) OUT -> IN Split(SplitStr)\nSplit() OUT -> IN Count(Counter) COUNT -> IN Display(Output)\nRead() ERROR -> IN Display()\n```\n\nNoFlo supports the FBP language fully. You can either load a graph with a string of FBP-language commands with:\n\n```coffeescript\nfbpData = \"<some FBP language connections>\"\n    \nnoflo = require \"noflo\"\nnoflo.graph.loadFbp fbpData, (graph) ->\n    console.log \"Graph loaded\"\n    console.log graph.toDOT()\n```\n\nThe `.fbp` file suffix is used for files containing FBP language. This means you can load them also the same way as you load JSON files, using the `noflo.loadFile` method, or the NoFlo shell. Example:\n\n    $ noflo examples/linecount/count.fbp     \n\n## Development\n\nNoFlo development happens on GitHub. Just fork the [main repository](https://github.com/bergie/noflo), make modifications and send a pull request.\n\nTo run the unit tests you need [nodeunit](https://github.com/caolan/nodeunit). Run the tests with:\n\n    $ nodeunit test\n\nor:\n\n    $ npm test\n\n## Discussion\n\nFlow-based programming in general, including NoFlo can be discussed on the [Flow Based Programming Google group](http://groups.google.com/group/flow-based-programming).\n\nThere is also an IRC channel `#fbp` on FreeNode.\n\n### Some ideas\n\n* Real-time status of the NoFlo graph via socket.io, see where data is flowing\n* [Web Workers](https://github.com/pgriess/node-webworker) based multiprocess runner\n* Sockets-based multi-computer runner, or possibly DNode\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/bergie/noflo/issues"
  },
  "_id": "noflo@0.3.4",
  "_from": "noflo@~0.3.4"
}
