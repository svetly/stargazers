(function() {
  var Port, events,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  events = require("events");

  Port = (function(_super) {
    __extends(Port, _super);

    function Port(type) {
      var _this = this;
      this.type = type;
      if (!this.type) {
        this.type = 'all';
      }
      this.socket = null;
      this.from = null;
      this.downstreamIsGettingReady = false;
      this.groups = [];
      this.data = [];
      this.buffer = [];
      this.on("ready", function() {
        var conn, datum, group, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        if (_this.downstreamIsGettingReady) {
          _this.downstreamIsGettingReady = false;
          _ref = _this.buffer;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            conn = _ref[_i];
            _ref1 = conn.groups;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              group = _ref1[_j];
              _this.beginGroup(group);
            }
            _ref2 = conn.data;
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              datum = _ref2[_k];
              _this.send(datum);
            }
            _ref3 = conn.groups;
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              group = _ref3[_l];
              _this.endGroup();
            }
            _this.disconnect();
          }
          return _this.buffer = [];
        }
      });
    }

    Port.prototype.attach = function(socket) {
      if (this.isAttached()) {
        throw new Error("" + this.name + ": Socket already attached " + (this.socket.getId()) + " - " + (socket.getId()));
      }
      this.socket = socket;
      return this.attachSocket(socket);
    };

    Port.prototype.attachSocket = function(socket, localId) {
      var _this = this;
      if (localId == null) {
        localId = null;
      }
      this.emit("attach", socket);
      this.from = socket.from;
      socket.setMaxListeners(0);
      socket.on("connect", function() {
        return _this.emit("connect", socket, localId);
      });
      socket.on("begingroup", function(group) {
        return _this.emit("begingroup", group, localId);
      });
      socket.on("data", function(data) {
        return _this.emit("data", data, localId);
      });
      socket.on("endgroup", function(group) {
        return _this.emit("endgroup", group, localId);
      });
      return socket.on("disconnect", function() {
        return _this.emit("disconnect", socket, localId);
      });
    };

    Port.prototype.connect = function() {
      if (this.downstreamIsGettingReady) {
        return;
      }
      if (!this.socket) {
        throw new Error("No connection available");
      }
      return this.socket.connect();
    };

    Port.prototype.beginGroup = function(group) {
      var _this = this;
      if (this.downstreamIsGettingReady) {
        this.groups.push(group);
        return;
      }
      if (!this.socket) {
        throw new Error("No connection available");
      }
      if (this.isConnected()) {
        return this.socket.beginGroup(group);
      }
      this.socket.once("connect", function() {
        return _this.socket.beginGroup(group);
      });
      return this.socket.connect();
    };

    Port.prototype.send = function(data) {
      var _this = this;
      if (this.downstreamIsGettingReady) {
        this.data.push(data);
        return;
      }
      if (!this.socket) {
        throw new Error("No connection available");
      }
      if (this.isConnected()) {
        return this.socket.send(data);
      }
      this.socket.once("connect", function() {
        return _this.socket.send(data);
      });
      return this.socket.connect();
    };

    Port.prototype.endGroup = function() {
      if (this.downstreamIsGettingReady) {
        return;
      }
      if (!this.socket) {
        throw new Error("No connection available");
      }
      return this.socket.endGroup();
    };

    Port.prototype.disconnect = function() {
      var buffer;
      if (this.downstreamIsGettingReady) {
        buffer = {
          groups: this.groups,
          data: this.data
        };
        this.buffer.push(buffer);
        this.groups = [];
        this.data = [];
        return;
      }
      if (!this.socket) {
        return;
      }
      return this.socket.disconnect();
    };

    Port.prototype.detach = function(socket) {
      if (!this.isAttached(socket)) {
        return;
      }
      this.emit("detach", this.socket);
      this.from = null;
      return this.socket = null;
    };

    Port.prototype.isConnected = function() {
      if (!this.socket) {
        return false;
      }
      return this.socket.isConnected();
    };

    Port.prototype.isAttached = function() {
      return this.socket !== null;
    };

    return Port;

  })(events.EventEmitter);

  exports.Port = Port;

}).call(this);
