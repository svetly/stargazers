(function() {
  var Fbp, fs;

  fs = require('fs');

  Fbp = (function() {
    Fbp.prototype.matchExport = new RegExp("EXPORT=([A-Z\.]+):([A-Z]+)");

    Fbp.prototype.matchPort = new RegExp("([A-Z\.]+)");

    Fbp.prototype.matchComponent = new RegExp("([A-Za-z\.]+)\\(([A-Za-z0-9\/\.]+|)\:?([a-z\,]+)?\\)");

    Fbp.prototype.matchComponentGlobal = new RegExp("([A-Za-z\.]+)\\(([A-Za-z0-9\/\.]+|)\\)", "g");

    Fbp.prototype.matchInitial = new RegExp("\'(.*)\'");

    Fbp.prototype.matchConnection = new RegExp("\-\>");

    Fbp.prototype.matchSeparator = new RegExp("[\\s,\\n]");

    Fbp.prototype.matchSubgraph = new RegExp("\n *\\'(.+)\\' *-> *GRAPH *([A-Za-z\\.]+)\\(Graph\\) *\n");

    function Fbp() {
      this.lastElement = null;
      this.currentElement = null;
      this.currentNode = {};
      this.currentEdge = {};
      this.currentLine = 1;
      this.nodes = {};
      this.edges = [];
      this.exported = [];
    }

    Fbp.prototype.loadFile = function(file) {
      return fs.readFileSync(file, "utf-8", function(err) {
        if (err) {
          throw err;
        }
      });
    };

    Fbp.prototype.compileSubgraphs = function(string, currentFile) {
      var fbp, file, index, match, name, original, _ref;
      while (true) {
        match = string.match(this.matchSubgraph);
        if (match == null) {
          return string;
        } else {
          _ref = match, match = _ref[0], file = _ref[1], name = _ref[2], index = _ref[3], original = _ref[4];
          if (file === currentFile) {
            throw new Error("" + currentFile + " is attempting to use itself as a sub-graph");
          }
          fbp = this.compileSubgraphs(this.loadFile(file), file);
          fbp = fbp.replace(this.matchComponentGlobal, "" + name + ".$1($2)");
          string = string.replace(match, "\n" + fbp + "\n");
        }
      }
    };

    Fbp.prototype.parse = function(string) {
      var char, checkTerminator, component, connection, currentString, exported, index, initial, json, port, _i, _len;
      currentString = "";
      string = this.compileSubgraphs("\n" + string);
      for (index = _i = 0, _len = string.length; _i < _len; index = ++_i) {
        char = string[index];
        if (char === "\n") {
          this.currentLine++;
        }
        if (char === '#' && this.currentElement !== "initial") {
          this.currentElement = "comment";
          continue;
        }
        if (this.currentElement === "comment") {
          if (char === "\n") {
            this.currentElement = null;
          }
          continue;
        }
        if (char === "'") {
          if (this.currentElement === "initial") {
            this.currentElement = null;
          } else {
            this.currentElement = "initial";
          }
        }
        checkTerminator = this.matchSeparator.exec(char);
        if (this.currentElement === "initial") {
          checkTerminator = null;
        }
        if (!checkTerminator) {
          currentString += char;
        }
        if (!(checkTerminator || index === string.length - 1)) {
          continue;
        }
        if (currentString === 'EXPORT') {
          continue;
        }
        exported = this.matchExport.exec(currentString);
        if (exported) {
          this.handleExported(exported);
          currentString = "";
        }
        connection = this.matchConnection.exec(currentString);
        if (connection) {
          if (!(this.lastElement === "initial" || this.lastElement === "port")) {
            throw new Error("Port or initial expected, got " + currentString + " on line " + this.currentLine);
          }
          this.lastElement = "connection";
          this.handleConnection(connection);
          currentString = "";
        }
        initial = this.matchInitial.exec(currentString);
        if (initial) {
          if (this.lastElement !== null) {
            throw new Error("Newline expected, got " + currentString + " on line " + this.currentLine);
          }
          this.lastElement = "initial";
          this.handleInitial(initial);
          currentString = "";
        }
        component = this.matchComponent.exec(currentString);
        if (component) {
          if (!(this.lastElement === "port" || this.lastElement === null)) {
            throw new Error("Port or newline expected, got " + currentString + " on line " + this.currentLine);
          }
          this.lastElement = "component";
          this.handleComponent(component);
          currentString = "";
        }
        port = this.matchPort.exec(currentString);
        if (port) {
          if (!(this.lastElement === "connection" || this.lastElement === "component")) {
            throw new Error("Connection or component expected, got " + currentString + " on line " + this.currentLine);
          }
          this.lastElement = "port";
          this.handlePort(port);
          currentString = "";
        }
        if (char === "\n") {
          this.lastElement = null;
        }
      }
      return json = {
        properties: {
          name: ""
        },
        processes: this.nodes,
        connections: this.edges,
        exports: this.exported
      };
    };

    Fbp.prototype.handleExported = function(exported) {
      var exportedPort;
      exportedPort = {};
      exportedPort["private"] = exported[1].toLowerCase();
      exportedPort["public"] = exported[2].toLowerCase();
      return this.exported.push(exportedPort);
    };

    Fbp.prototype.handleConnection = function() {
      if (this.currentNode.name) {
        return this.currentEdge.src.process = this.currentNode.name;
      }
    };

    Fbp.prototype.handleInitial = function(initial) {
      this.currentNode = {
        data: initial[1]
      };
      this.currentEdge = {
        data: this.currentNode.data,
        tgt: {}
      };
      if (this.currentEdge.src) {
        return delete this.currentEdge.src;
      }
    };

    Fbp.prototype.handleComponent = function(component) {
      this.currentNode = {
        name: component[1],
        component: component[2]
      };
      if (component[3]) {
        this.currentNode.metadata = {
          routes: component[3].split(',')
        };
      }
      if (!this.nodes[this.currentNode.name]) {
        this.nodes[this.currentNode.name] = this.currentNode;
      }
      if (this.currentEdge.tgt && this.currentEdge.tgt.port) {
        this.currentEdge.tgt.process = this.currentNode.name;
        this.edges.push(this.currentEdge);
        this.currentEdge = {
          src: {},
          tgt: {}
        };
        return;
      }
      if (!this.currentEdge.src) {
        return this.currentEdge = {
          src: {
            process: this.currentNode.name
          },
          tgt: {}
        };
      }
    };

    Fbp.prototype.handlePort = function(port) {
      if (this.currentEdge.data !== void 0 || this.currentEdge.src.port) {
        this.currentEdge.tgt = {
          port: port[1].toLowerCase()
        };
        return;
      }
      return this.currentEdge.src.port = port[1].toLowerCase();
    };

    return Fbp;

  })();

  exports.Fbp = Fbp;

}).call(this);
